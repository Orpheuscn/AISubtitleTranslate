import type { SubtitleEntry } from '@/types'

export function useSrtProcessing() {
  // 解析SRT文件内容
  function parseSrt(content: string): SubtitleEntry[] {
    const entries: SubtitleEntry[] = []
    
    // 标准化换行符
    content = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n')
    
    // 按双换行符分割字幕块
    const blocks = content.split(/\n\s*\n/).filter(block => block.trim())
    
    blocks.forEach(block => {
      const lines = block.split('\n').map(line => line.trim())
      
      // 至少需要3行：序号、时间轴、文本
      if (lines.length < 3) return
      
      // 解析序号
      const index = parseInt(lines[0])
      if (isNaN(index)) return
      
      // 解析时间轴 (格式: 00:00:20,000 --> 00:00:24,400)
      const timeMatch = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/)
      if (!timeMatch) return
      
      const startTime = timeMatch[1]
      const endTime = timeMatch[2]
      
      // 剩余的行都是文本内容
      const text = lines.slice(2).join('\n')
      
      entries.push({
        index,
        startTime,
        endTime,
        text,
        translatedText: undefined,
        isMissing: false
      })
    })
    
    return entries
  }
  
  // 生成SRT文件内容
  function generateSrt(entries: SubtitleEntry[], useTranslation = true): string {
    let result = ''
    
    entries.forEach(entry => {
      result += `${entry.index}\n`
      result += `${entry.startTime} --> ${entry.endTime}\n`
      
      // 使用翻译文本或原文
      const text = useTranslation && entry.translatedText 
        ? entry.translatedText 
        : entry.text
      
      result += `${text}\n\n`
    })
    
    return result.trim()
  }
  
  // 提取用于翻译的纯文本（带序号）
  function extractTextForTranslation(entries: SubtitleEntry[]): string {
    return entries.map(entry => `[${entry.index}] ${entry.text}`).join('\n\n')
  }
  
  // 从翻译结果中提取文本并填充到字幕条目中
  function parseTranslationResult(
    translationResult: string,
    entries: SubtitleEntry[]
  ): void {
    // 分离翻译文本和专有名词部分
    let translationPart = translationResult
    const separator = '### Proper Nouns:'
    const separatorIndex = translationResult.indexOf(separator)

    if (separatorIndex !== -1) {
      translationPart = translationResult.substring(0, separatorIndex).trim()
    }

    // 解析翻译结果 - 改进版：支持多行翻译内容
    // 使用正则匹配所有 [数字] 标记及其后续内容
    const indexPattern = /\[(\d+)\]/g
    const translationMap = new Map<number, string>()

    let match
    const matches: Array<{ index: number; position: number }> = []

    // 找到所有序号标记的位置
    while ((match = indexPattern.exec(translationPart)) !== null) {
      matches.push({
        index: parseInt(match[1]),
        position: match.index
      })
    }

    // 提取每个序号对应的翻译内容（从当前序号到下一个序号之间的所有内容）
    for (let i = 0; i < matches.length; i++) {
      const current = matches[i]
      const next = matches[i + 1]

      // 提取内容：从当前 [数字] 标记后到下一个 [数字] 标记前（或到结尾）
      const startPos = current.position
      const endPos = next ? next.position : translationPart.length
      const fullText = translationPart.substring(startPos, endPos)

      // 移除开头的 [数字] 标记，保留后续所有内容（包括换行）
      const translation = fullText.replace(/^\[\d+\]\s*/, '').trim()

      if (translation) {
        translationMap.set(current.index, translation)
      }
    }

    // 将翻译结果填充到对应的字幕条目
    entries.forEach(entry => {
      const translation = translationMap.get(entry.index)
      if (translation) {
        entry.translatedText = translation
        entry.isMissing = false
      } else {
        entry.translatedText = '[翻译缺失]'
        entry.isMissing = true
      }
    })
  }
  
  // 生成双语ASS字幕
  function generateBilingualASS(entries: SubtitleEntry[]): string {
    let result = `[Script Info]
; Script generated by AI Subtitle Translate
Title: Bilingual Subtitle
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: None

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Source,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,8,10,10,10,1
Style: Translation,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,0,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`

    entries.forEach(entry => {
      const startTime = convertSRTTimeToASS(entry.startTime)
      const endTime = convertSRTTimeToASS(entry.endTime)

      // 原文在顶部
      const sourceText = entry.text.replace(/\n/g, '\\N')
      result += `Dialogue: 0,${startTime},${endTime},Source,,0,0,0,,${sourceText}\n`

      // 译文在底部
      if (entry.translatedText && !entry.isMissing) {
        const translationText = entry.translatedText.replace(/\n/g, '\\N')
        result += `Dialogue: 0,${startTime},${endTime},Translation,,0,0,0,,${translationText}\n`
      }
    })

    return result
  }

  // 将SRT时间格式转换为ASS时间格式
  // SRT: 00:00:20,000 -> ASS: 0:00:20.00
  function convertSRTTimeToASS(srtTime: string): string {
    const match = srtTime.match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})/)
    if (!match) return '0:00:00.00'

    const hours = parseInt(match[1])
    const minutes = match[2]
    const seconds = match[3]
    const milliseconds = match[4]

    // 将毫秒转换为百分之一秒
    const centiseconds = Math.floor(parseInt(milliseconds) / 10).toString().padStart(2, '0')

    return `${hours}:${minutes}:${seconds}.${centiseconds}`
  }

  // 下载文件（通用）
  function downloadFile(content: string, filename: string, mimeType: string = 'text/plain;charset=utf-8'): void {
    const blob = new Blob([content], { type: mimeType })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = filename
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    URL.revokeObjectURL(url)
  }

  // 下载SRT文件
  function downloadSrt(content: string, filename: string): void {
    downloadFile(content, filename, 'text/plain;charset=utf-8')
  }

  // 下载ASS文件
  function downloadAss(content: string, filename: string): void {
    downloadFile(content, filename, 'text/plain;charset=utf-8')
  }

  return {
    parseSrt,
    generateSrt,
    extractTextForTranslation,
    parseTranslationResult,
    generateBilingualASS,
    downloadSrt,
    downloadAss,
    downloadFile
  }
}

